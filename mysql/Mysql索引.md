## Mysql索引

#### 为啥需要索引？？

- 索引可以提高查询效率



#### 索引的常见模型

- Hash表
- 有序数组
- 二叉树
- N叉树

###### Hash表

- 计算待存储的数据的Hash值，然后放到对应一个数组下标位置
- 优点：添加很快，因为只需要添加到拉链的尾部
- 缺点：范围查找的话很慢，需要扫描全表，消耗比较大
- 适应场景：Memcached引擎就是用Hash表作为索引模型，比较适合等值查询

###### 有序数组

- 有顺序的数组
- 优点：等值查询（log(N)）和范围查询性能都非常优秀
- 缺点：添加的时候代价比较大
- 适应场景：只适合静态存储引擎，数据变化不大，新增数据不多

###### 二叉树

- 每个节点最多有两个子节点，左小右大

- 优点：查询和添加效率都很快（log(N)）

- 缺点：高度比较高，这样大部分的节点在磁盘上，高度为N，可能需要N次把磁盘数据读取到内存（IO比较多）

  

###### N叉树

- 一个节点有N个子节点
- 优点：查询和添加效率都很快，并且IO次数比较少，因为每一层节点多了，高度就小了，IO肯定就少了

------







#### InnnoDB存储引擎

- B+树是InnnoDB的索引模型
- 一个索引对应InnoDB中的一颗B+树
- 索引按照索引类型分为：主键索引和非主键索引

###### 主键索引

- InnoDB中也叫聚簇索引
- 叶子节点存储的是整行数据

###### 非主键索引

- InnoDB中也叫二级索引
- 叶子节点存储的是主键的值

###### 基于主键索引和非主键索引查询有啥区别？？

````SQL
select * from XXX where 主键 = 1;
````

- 主键索引查询，通过主键索引B+树，直接找到叶子节点中存储的整行数据（1次查找B+树）

````SQL
select * from XXX where 非主键索引列属性 = 3;
````

- 非主键索引，通过非主键索引找B+树中的叶子节点中对应的主键值，然后拿到主键值去主键索引B+树中去查找叶子节点中的整行数据（2次查找B+树），这个过程叫做回表

###### 索引的维护

- 主键索引如果自增添加的话，没啥大问题
- 主键索引如果不是自增添加的话，如果后面的数据所在数据页大小不够了，肯定要去申请新数据页，然后把数据移动一部分过去，这样就页分裂了，性能肯定有影响
- 建议：基于上面一点，我们建议主键自增，那样的话不会出现页分裂
- 由于每个二级索引B+树的叶子节点上都是主键值，如果主键比较占空间，那么岂不是很浪费空间
- 建议：主键长度小点

###### 有什么场景用自定义值来做主键索引？？

- 只有一个主键索引
- 索引必须是唯一的



###### 索引覆盖

- 索引覆盖是解决回表的问题，提高查询性能

````SQL
select ID from T where k between 3 and 5    
````

- 说明：主键是ID字段，k为二级索引，在二级索引B+树中，从叶子节点3位置开始找，找到3-5的主键ID，这样就避免了回表

