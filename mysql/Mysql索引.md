## Mysql索引

#### 为啥需要索引？？

- 索引可以提高查询效率



#### 索引的常见模型

- Hash表
- 有序数组
- 二叉树
- N叉树

###### Hash表

- 计算待存储的数据的Hash值，然后放到对应一个数组下标位置
- 优点：添加很快，因为只需要添加到拉链的尾部
- 缺点：范围查找的话很慢，需要扫描全表，消耗比较大
- 适应场景：Memcached引擎就是用Hash表作为索引模型，比较适合等值查询

###### 有序数组

- 有顺序的数组
- 优点：等值查询（log(N)）和范围查询性能都非常优秀
- 缺点：添加的时候代价比较大
- 适应场景：只适合静态存储引擎，数据变化不大，新增数据不多

###### 二叉树

- 每个节点最多有两个子节点，左小右大

- 优点：查询和添加效率都很快（log(N)）

- 缺点：高度比较高，这样大部分的节点在磁盘上，高度为N，可能需要N次把磁盘数据读取到内存（IO比较多）

  

###### N叉树

- 一个节点有N个子节点
- 优点：查询和添加效率都很快，并且IO次数比较少，因为每一层节点多了，高度就小了，IO肯定就少了

------







#### InnnoDB存储引擎

- B+树是InnnoDB的索引模型
- 一个索引对应InnoDB中的一颗B+树
- 索引按照索引类型分为：主键索引和非主键索引

###### 主键索引

- InnoDB中也叫聚簇索引
- 叶子节点存储的是整行数据

###### 非主键索引

- InnoDB中也叫二级索引
- 叶子节点存储的是主键的值

###### 基于主键索引和非主键索引查询有啥区别？？

````SQL
select * from XXX where 主键 = 1;
````

- 主键索引查询，通过主键索引B+树，直接找到叶子节点中存储的整行数据（1次查找B+树）

````SQL
select * from XXX where 非主键索引列属性 = 3;
````

- 非主键索引，通过非主键索引找B+树中的叶子节点中对应的主键值，然后拿到主键值去主键索引B+树中去查找叶子节点中的整行数据（2次查找B+树），这个过程叫做回表

###### 索引的维护

- 主键索引如果自增添加的话，没啥大问题
- 主键索引如果不是自增添加的话，如果后面的数据所在数据页大小不够了，肯定要去申请新数据页，然后把数据移动一部分过去，这样就页分裂了，性能肯定有影响
- 建议：基于上面一点，我们建议主键自增，那样的话不会出现页分裂
- 由于每个二级索引B+树的叶子节点上都是主键值，如果主键比较占空间，那么岂不是很浪费空间
- 建议：主键长度小点

###### 有什么场景用自定义值来做主键索引？？

- 只有一个主键索引
- 索引必须是唯一的



###### 索引覆盖

- 索引覆盖是解决回表的问题，提高查询性能

````SQL
select ID from T where k between 3 and 5    
````

- 说明：主键是ID字段，k为二级索引，在二级索引B+树中，从叶子节点3位置开始找，找到3-5的主键ID，这样就避免了回表

- 有时候设计冗余的联合索引来避免回表

###### 最左前缀原则

- 联合索引B+树，里面的数据是按照索引设计的先后顺序来排序的
- 最左前缀，可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符

###### 索引下推

````
select * from tuser where name like '张%' and age=10 and ismale=1;
````

- (name, age)为联合索引
- MySql5.6之后，在联合索引树中，1.找到和张匹配的  2.检查age是不是等于10  3.等于10的话就拿主键去主键索引树里面回表



#### 唯一索引和普通索引怎么选择

###### 唯一索引和普通索引在查询时候的性能

- 唯一索引，从根节点开始找，找到叶子节点里面满足条件的数据，停止检索直接返回 （找到了直接停止）
- 普通索引，从根开始找，找到叶子节点里面满足的数据，直到碰到不满足条件的才停止检索 （遇到不满足的才会停止）
- 数据库是以数据页为数据的基本单位的，一般读取数据的时候是读取整个数据页到内存，像普通索引中，找到下个不符合的时候才会停止检索，其实性能消耗不大
- 总结：唯一索引和普通索引在查询中，性能相差不大



###### 唯一索引和普通索引在更新时候的性能

- 唯一索引，在更新的时候，需要将数据页读到内存里面，然后索引是不是唯一的，然后更新
- 普通索引，在更新的时候，先看看内存有没有相关数据页，有的话直接更新。没有的话，先写到change buffer里面去

###### change buffer

- change buffer其实是一个持久化的数据
- change buffer相当于存储的是更新操作，等到特定的时机才会把change buffer里面的数据合并到磁盘中的数据页里面
- 什么时候会触发合并呢？？
  - 1. 当查询整个数据页的时候
    2. 系统后台线程会定期merge
    3. 数据库shutdown的时候
- 什么时候建议使用change buffer呢？
  - change buffer只适合普通索引使用
  - 写多读少的时候，比较适合使用
    - 为什么？？ 因为把change buffer累积到一定的量的时候，再去merge，肯定比经常merge性能要好
- 什么时候不建议使用？
  - 就是那种，我更新以后，马上就去读它了，这样就在读的时候触发merge，如果经常这样，IO的次数 不会减少，还增加了维护change buffer的成本
- 总结：普通索引+change buffer这个机制收效是显著的。



###### 字符串索引

- 字符串索引可以指定索引的长度，前缀索引。
- 字符串前缀索引
  - 先从叶子节点中，找到和条件匹配的节点，然后拿到节点的data中的主键去主键索引树中进行回表，判断是不是和条件一致，发现叶子节点中的和匹配条件不一致的话，停止检索
  - 字符串前缀索引，无法实现索引覆盖避免回表，因为它是一个like类型的，他必须去主键索引树种去确定一下
- 总结
  - 1. 直接创建完整的字符串索引，如果字段过长的话，会占用更多的空间
    2. 创建字符串前缀索引，空间占用少了，但是查询效率低一些，并且不能实现索引覆盖
    3. 倒序存储，再加上前缀索引，用于解决字符串前缀区分度不够的问题
    4. 创建hash字段索引，查询性能稳定，但是又格外的计算和存储的消耗

